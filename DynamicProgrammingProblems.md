## Задачи за Динамично програмиране

1. **[MinimumCoinCount]** Разполагаме с **n** вида монети със стойности **c<sub>1</sub>**,**c<sub>2</sub>**,...,**c<sub>n</sub>** и неограничен брой монети от всеки вид. С колко най-малко монети може да се събере сума **S**?
2. **[MinimumCoinCountLimited]** Нека е дадено конкретно мултимножество монети със стойности **c<sub>1</sub>**,**c<sub>2</sub>**,...,**c<sub>n</sub>**. С колко най-малко монети може да се събере сума **S**?
3. **[Tiling2xN]** По колко начина може да се покрие дъска с размери **2xN** с плочки **2x1**? Плочките могат да се слагат хоризонтално и вертикално и не трябва да "излизат" от границите на дъската.
4. **[PictureProfit]** В галерия са подредени в редица **n** картини на стойност **c<sub>1</sub>**,**c<sub>2</sub>**,...,**c<sub>n</sub>**. Можем да откраднем колкото картини искаме, стига да не взимаме някоя двойка съседни. Каква най-голяма печалба можем да получим?
5. **[PictureProfitC]** Ами ако картините от горната задача са подредени в кръг и картини **1** и **n** също са съседни помежду си?
6. **[MinimumSquareCount]** Да се намери минималният брой квадрати на естествени числа (може да се повтарят), които дават сума **N**.
7. **[CopyPaste]** Нека сме отворили празен текстови файл и имаме 4 варианта за действие - да вмъкнем един символ накрая (insert), да селектираме цялото текущо съдържание на файла (Ctrl-A), да копираме селектираното в буфера (Ctrl-C, има смисъл само след Ctrl-A) и да поставим цялото съдържание на буфера в края на файла (Ctrl-V, отново има смисъл само след Ctrl-C и оставя буфера празен). Да се изчисли колко най-голям може да стане файлът след **n** действия. Ами ако Ctrl-V не оставя буфера празен и е позволено последователното поставяне?
8. **[FunnyIterator]** Нека е дадено естествено число **n**. Можем или да го намалим с едно, или да го разделим на две (но само ако е четно) или да го разделим на три (само ако се дели точно). Да се намери с колко най-малко действия можем от числото **n** да получим единица.
9. **[LongestIncreasingSubsequence]** Да се намери най-голямата нарастваща подредица в масив от числа.
10. **[MatrixMultiplication]** Дадени са **n** матрици с размери **d<sub>0</sub>\*d<sub>1</sub>**, **d<sub>1</sub>\*d<sub>2</sub>**,...,**d<sub>n-1</sub>\*d<sub>n</sub>**. Знаем, че "цената" да умножим матрица **m\*n** с матрица **n\*p** е **mnp**. Да се намери в какъв ред трябва да бъдат умножени всички матрици, за да се постигне минимална сумарна цена.
11. **[OptimalSingleRobotPath]** Робот се намира в горния ляв край на матрица **NxM** и може да се движи само надолу и надясно. Каква е максималната сума от числа, която може да се събере по някой маршрут до долния десен ъгъл на матрицата?
12. **[OptimalTwoRobotPath]** Два робота тръгват едновременно от горния ляв ъгъл на матрица **NxM**, движейки се само надолу и надясно. Каква е максималната сума, която могат общо да съберат, стигайки независимо до долния десен ъгъл? Ако и двата минат през една и съща позиция, числото ще се прибави само веднъж към сумата.
13. **[BinomialCoefficient]** Да се изчисли биномния коефициент **n** над **k**.
14. **[nDigitIntegerCount]** Колко са **n**-цифрените числа в десетична бройна система със сума на цифрите **S**?
15. **[Knapsack]**
16. **[KnapsackNoRepetitions]**
17. **[Partition]**
18. **[EqualSumSubsets]**
19. **[MaximumSubarraySum]** Да се намери максималната сума, образувана от някой подмасив на даден масив с числа. Забележете разликата подмасив != подредица.
20. **[MaximumSubmatrixSum]** Да се намери максималната сума, образувана от някоя подматрица на дадена матрица с числа.
21. **[LongestCommonSubsequence]** Да се намери най-дългата обща подредица на два масива
22. **[IntegerPartitions]** По колко начина може число **N** да се разбие на сума от по-малки числа? Например за N=4 има 5 начина: 4, 3+1, 2+2, 2+1+1 и 1+1+1+1 - забележете, че не разпознаваме 1+3 или 1+2+1 като възможности.
23. **[LevenshteinDistance]** Нека са дадени два низа, **s1** и **s2**, и са позволени следните операции за редактиране: вмъкване на символ на произволна позиция, премахване на символ от произволна позиция, и субституция на символ на произволна позиция с друг. Да се намери минималния брой операции, нужни за получаването на низа **s2** чрез редактиране на **s1**.
24. **[MinimumPalindromeSubstrings]** Да се намери минималният брой палиндроми, на които може да се разбие даден низ.
25. **[MinimumDeletionsToPalindrome]** Да се намери колко най-малко символа могат да се премахнат от даден низ до получаването на палиндром.
26. **[LargestWhiteSquare]** Даден е черно-бял bitmap. Да се намери най-големият бял квадрат.
