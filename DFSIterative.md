```
DFSIterative(G(V,E): graph)
 1. foreach u in V
 2.   visited[u] <- False
 3.   pred[u] <- NIL
 4. S <- празен стек
 5. foreach u in V
 6.   if !visited[u]
 7.     S.push(u)
 8.   while S не е празен
 9.     v <- S.pop()
10.     if !visited[v]
11.       visited[v] <- True
12.       foreach w in Adj(v)
13.         pred[w] <- v
14.         S.push(w)
```

Сложността по време и памет е `T(n,m) = M(n,m) = Θ(n+m)`. Причината за увеличената памет е, че даден връх може да бъде вмъкнат в стека повече от веднъж (затова и проверката на ред 10) - необходимо, за да си гарантираме коректността на търсенето в дълбочина. Факт е и, че ред 13 тогава може да пише няколко пъти в една и съща клетка в масива `pred`.
