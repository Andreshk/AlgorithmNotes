```
Median-of-medians(A[0..n-1] : array of numbers) // zero-based indexing for convenience
 1. while n > 20 // good choice for an arbitrary constant
 2.   ndiv5 <- n/5, nmod5 <- n%5 // integer division
 3.   for i <- 0 to ndiv5-1
 4.     SortNaive(A[i*5..i*5+4]) // hopefully inlined
 5.     A[i] <- A[i*5+2]
 6.   if nmod5 != 0
 7.     SortNaive(A[n-nmod5..n-1])
 8.     A[ndiv5] <- A[n - (nmod5/2)]
 9.   n <- ndiv5 + (nmod5 != 0)
10. SortNaive(A[0..n-1])
11. if n is odd
12.   return A[n/2]
13. else
14.   return (A[n/2 - 1] + A[n/2])/2
```
`Median-of-medians` е класически _апроксимационен_ алгоритъм, който **не** гарантира, че връща медианата за даден масив, но със сигурност връща елемент, който не е в първите или последните 30% от масива (т.е. се намира между 30-тия и 70-тия персентил от елементите). Тъй като сложността му по време е `O(n)` (доказва се лесно по индукция) и заради константния фактор от (поне) 30%, този алгоритъм може да се използва за избор на `pivot` в `QuickSort` и `QuickSelect`, гарантирайки тяхната сложността по време в най-лошия случай от `O(nlgn)` и `O(n)`, респективно. На практика е по-бавен от рандомизирани алгоритми за избор на `pivot`, но е полезен и лесен пример за апроксимационен алгоритъм. Друга употреба е за разбиване на входящите данни при построение на [k-d дърво](https://en.wikipedia.org/wiki/K-d_tree). Доказателство за коректност на алгоритъма можете да видите [тук](https://en.wikipedia.org/wiki/Median_of_medians#Properties_of_pivot) - имайте предвид, че при апроксимационните алгоритми под доказателство за коректност се разбира нещо по-специално.

Алгоритъмът работи на следния принцип:
- разбива масива на парченца от по пет елемента
- сортира тези парченца наивно и намира медианите им (тривиално)
- записва всички медиани в началото на масива и се извиква рекурсивно за подмасива, състоящ се само от тях (оттам и името на алгоритъма)
- когато елементите за обработване станат "твърде" малко, се избира медианата им отново по наивен начин
  
За `SortNaive` сортиращ алгоритъм най-добрият избор е `InsertionSort`, т.к. се сортират само малки броеве елементи. В псевдокода по-горе рекурсивните извиквания съответстват на итерациите на `while` цикъла върху презаписаната част от оригиналния масив. Обърнете внимание, че масивът `A` се индексира с индекси между 0 и `n-1`, включително.
